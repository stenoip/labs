<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebXR AR Placement Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#000; }
    canvas { display:block; }
    #hint {
      position: fixed; left: 50%; bottom: 20px; transform: translateX(-50%);
      padding: 10px 14px; border-radius: 8px; background: rgba(0,0,0,0.6);
      color: #fff; font-family: system-ui, sans-serif;
      font-size: 14px; pointer-events: none;
    }
  </style>
</head>
<body>
<div id="hint">Move your phone to find a surface, then tap to place.</div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.164.1/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.164.1/examples/jsm/webxr/ARButton.js';

let renderer, scene, camera;
let hitTestSource = null, hitTestSourceRequested = false;
let reticle;
let objects = [];

init();
animate();

function init() {
  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  // AR button
  const arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
  document.body.appendChild(arButton);

  // Scene & camera
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(0.5, 1, 0.3);
  scene.add(dir);

  // Reticle
  reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.08, 0.1, 32),
    new THREE.MeshBasicMaterial({ color: 0x00e0ff, side: THREE.DoubleSide })
  );
  reticle.rotation.x = -Math.PI / 2;
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // Tap to place (touch + XR select)
  renderer.domElement.addEventListener('touchstart', onPlace);
  renderer.xr.addEventListener('sessionstart', () => {
    const session = renderer.xr.getSession();
    session.addEventListener('select', onPlace);
  });

  // Resize
  window.addEventListener('resize', onResize);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function createObject() {
  const group = new THREE.Group();

  const cube = new THREE.Mesh(
    new THREE.BoxGeometry(0.15, 0.15, 0.15),
    new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff })
  );
  cube.position.y = 0.075;
  group.add(cube);

  group.userData.update = () => { cube.rotation.y += 0.01; };
  return group;
}

function onPlace() {
  console.log("Tap/select event fired. Reticle visible:", reticle.visible);
  if (!reticle.visible) return;
  const obj = createObject();
  obj.position.setFromMatrixPosition(reticle.matrix);
  obj.quaternion.setFromRotationMatrix(reticle.matrix);
  scene.add(obj);
  objects.push(obj);

  const hint = document.getElementById('hint');
  if (hint) hint.style.display = 'none';
}

function requestHitTestSource(session, referenceSpace) {
  return session.requestReferenceSpace('viewer').then((viewerSpace) =>
    session.requestHitTestSource({ space: viewerSpace }).then((source) => {
      hitTestSource = source;
      hitTestSourceRequested = true;
      session.addEventListener('end', () => {
        hitTestSourceRequested = false;
        hitTestSource = null;
      });
    })
  );
}

function animate() {
  renderer.setAnimationLoop(render);
}

function render(timestamp, frame) {
  for (const obj of objects) {
    if (obj.userData.update) obj.userData.update();
  }

  const session = renderer.xr.getSession();
  if (frame && session) {
    const referenceSpace = renderer.xr.getReferenceSpace();

    if (!hitTestSourceRequested) {
      requestHitTestSource(session, referenceSpace).catch(() => {});
    }

    if (hitTestSource) {
      const hitTestResults = frame.getHitTestResults(hitTestSource);
      if (hitTestResults.length) {
        const pose = hitTestResults[0].getPose(referenceSpace);
        reticle.visible = true;
        reticle.matrix.fromArray(pose.transform.matrix);
      } else {
        reticle.visible = false;
      }
    }
  }

  renderer.render(scene, camera);
}
</script>
</body>
</html>
