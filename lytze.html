<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lytze the Fuzbal Prototype</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000008; }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="sim"></canvas>
<script>
var canvas = document.getElementById('sim');
var ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- Game State and Constants ---
const PLAYER_BALL_INDEX = 0; // Lytze will be the first ball
const LYTZE_IMAGE_URL = 'lytze.png'; 
const BALL_COUNT = 10;
const COIN_RADIUS = 12;

var lytzeImage = new Image();
lytzeImage.src = LYTZE_IMAGE_URL;

var stats = { absorbed: 0, mergers: 0, level: 1, wins: 0 };
var coin = { x: 0, y: 0, active: false };

// Black hole constructor (kept as is)
function BlackHole(x, y, mass) {
  this.x = x;
  this.y = y;
  this.vx = 0;
  this.vy = 0;
  this.mass = mass || 4.5e4;
  this.G = 28.0;
  this.omega = 0.5;
  this.horizon = 42;
  this.softening = 120;
  this.swirlStrength = 180.0;
  this.accCap = 2500;
  this.energyBurst = 0; // for merger flash
}

var blackHoles = [ new BlackHole(canvas.width/2, canvas.height/2) ];
var balls = [];

function randRange(a, b) { return a + Math.random() * (b - a); }
function polarToXY(cx, cy, r, ang) { return { x: cx + r * Math.cos(ang), y: cy + r * Math.sin(ang) }; }

// --- Level Management ---

function setupLevel(level) {
  stats.level = level;
  stats.absorbed = 0; // Reset stats for the level
  stats.mergers = 0;
  blackHoles.length = 0;
  balls.length = 0;
  coin.active = false;
  
  var cx = canvas.width/2, cy = canvas.height/2;

  // Level-specific setup
  if (level === 1) {
    // Single BH in the center
    blackHoles.push(new BlackHole(cx, cy, 4.5e4));
    // Place coin far from the center
    var coinR = Math.min(canvas.width, canvas.height) * 0.45;
    var coinAng = randRange(0, Math.PI * 2);
    var coinPos = polarToXY(cx, cy, coinR, coinAng);
    coin.x = coinPos.x;
    coin.y = coinPos.y;
    coin.active = true;
  } else if (level === 2) {
    // Two black holes, smaller
    var offset = 150;
    blackHoles.push(new BlackHole(cx - offset, cy, 3e4));
    blackHoles.push(new BlackHole(cx + offset, cy, 3e4));
    
    // Place coin near the edge
    var coinR = Math.min(canvas.width, canvas.height) * 0.4;
    var coinAng = randRange(0, Math.PI * 2);
    var coinPos = polarToXY(cx, cy, coinR, coinAng);
    coin.x = coinPos.x;
    coin.y = coinPos.y;
    coin.active = true;
  } else {
    // Default / Victory screen
    alert('You beat all levels! The game is over.');
    blackHoles.push(new BlackHole(cx, cy));
    stats.level = 'Finished';
    coin.active = false;
  }

  initBalls();
}

function initBalls() {
  balls.length = 0;
  var cx = canvas.width/2, cy = canvas.height/2;
  var bh = blackHoles[0] || { G: 28.0, mass: 4.5e4, softening: 120 }; // Use first BH or defaults

  for (var i = 0; i < BALL_COUNT; i++) {
    var r = randRange(140, Math.min(canvas.width, canvas.height) * 0.35);
    var ang = randRange(0, Math.PI * 2);
    var pos = polarToXY(cx, cy, r, ang);

    var vCirc = Math.sqrt((bh.G * bh.mass) / (r + bh.softening));
    var tx = -Math.sin(ang);
    var ty =  Math.cos(ang);

    var jitter = (i === PLAYER_BALL_INDEX) ? 0.0 : 0.25 * vCirc; // Lytze starts with less jitter
    var vx = tx * vCirc + randRange(-jitter, jitter);
    var vy = ty * vCirc + randRange(-jitter, jitter);

    balls.push({
      x: pos.x, y: pos.y, vx: vx, vy: vy,
      color: pickColor(i),
      
      /* THIS is how to make lytze bigger. 
                                           |
                                           |
                                           V      */
      radius: (i === PLAYER_BALL_INDEX) ? 30 : 6 + (i % 3), 
      
      
      life: 0,
      isLytze: (i === PLAYER_BALL_INDEX)
    });
  }
}

function pickColor(i) {
  var palette = [
    '#F0F0F0', // Lytze's color
    '#5DADE2', '#F5B041', '#AF7AC5',
    '#E74C3C', '#1ABC9C', '#F4D03F', '#3498DB',
    '#F39C12', '#9B59B6', '#2ECC71', '#EC7063'
  ];
  return palette[i % palette.length];
}

var last = performance.now();
function step(now) {
  var dt = Math.min(0.035, (now - last) / 1000);
  last = now;

  fadeTrail(0.12);

  // Black hole mutual gravity (BH loop kept as is)
  for (var i = 0; i < blackHoles.length; i++) {
    var BH1 = blackHoles[i];
    var ax = 0, ay = 0;
    for (var j = 0; j < blackHoles.length; j++) {
      if (i === j) continue;
      var BH2 = blackHoles[j];
      var rx = BH2.x - BH1.x;
      var ry = BH2.y - BH1.y;
      var r2 = rx*rx + ry*ry;
      var r = Math.sqrt(r2);
      if (r < BH1.horizon + BH2.horizon) {
        // Merge
        mergeBlackHoles(i, j);
        return requestAnimationFrame(step);
      }
      var ux = rx / (r+1e-6);
      var uy = ry / (r+1e-6);
      var grav = (BH1.G * BH2.mass) / (r2 + BH1.softening*BH1.softening);
      ax += ux * grav;
      ay += uy * grav;
    }
    BH1.vx += ax * dt;
    BH1.vy += ay * dt;
  }

  // Update BH positions
  for (var i = 0; i < blackHoles.length; i++) {
    var BH = blackHoles[i];
    BH.x += BH.vx * dt;
    BH.y += BH.vy * dt;
    drawBlackHole(BH);
  }

  // Draw coin *before* balls so Lytze can cover it
  if (coin.active) {
    drawCoin(coin);
    checkWinCondition(balls[PLAYER_BALL_INDEX]);
  }
  
  // Balls (Lytze included)
  for (var j = 0; j < balls.length; j++) {
    var b = balls[j];
    var ax = 0, ay = 0;
    for (var k = 0; k < blackHoles.length; k++) {
      var BH = blackHoles[k];
      var rx = BH.x - b.x;
      var ry = BH.y - b.y;
      var r2 = rx*rx + ry*ry;
      var r = Math.sqrt(r2);
      var ux = r > 1e-6 ? rx/r : 0;
      var uy = r > 1e-6 ? ry/r : 0;
      var px = -uy, py = ux;
      var gravMag = (BH.G * BH.mass) / (r2 + BH.softening*BH.softening);
      ax += ux * gravMag;
      ay += uy * gravMag;
      var swirlMag = BH.swirlStrength * BH.omega / (r+1);
      ax += px * swirlMag;
      ay += py * swirlMag;
      if (r < BH.horizon) {
        // Collision with black hole
        if (b.isLytze) {
          // Lytze loses! Restart level.
          alert('Lytze was absorbed! Restarting Level ' + stats.level);
          setupLevel(stats.level);
          return requestAnimationFrame(step);
        } else {
          stats.absorbed++;
          respawn(b);
        }
      }
    }
    var damping = 0.02;
    ax -= b.vx * damping;
    ay -= b.vy * damping;
    var a2 = ax*ax + ay*ay;
    if (a2 > blackHoles[0].accCap*blackHoles[0].accCap) {
      var a = Math.sqrt(a2);
      var scale = blackHoles[0].accCap / a;
      ax *= scale; ay *= scale;
    }
    b.vx += ax*dt;
    b.vy += ay*dt;
    b.x += b.vx*dt;
    b.y += b.vy*dt;
    b.life += dt;
    drawBall(b);
  }

  drawHUD();
  requestAnimationFrame(step);
}

function checkWinCondition(lytze) {
  if (!lytze || !coin.active) return;

  var dx = lytze.x - coin.x;
  var dy = lytze.y - coin.y;
  var distance = Math.sqrt(dx*dx + dy*dy);

  if (distance < lytze.radius + COIN_RADIUS) {
    // Lytze collected the coin! Win condition met.
    stats.wins++;
    coin.active = false;
    alert('Level ' + stats.level + ' cleared! Time for Level ' + (stats.level + 1) + '!');
    setupLevel(stats.level + 1);
  }
}


// --- Drawing Functions ---

function drawCoin(c) {
  var size = COIN_RADIUS;
  // Draw a simple yellow coin
  ctx.save();
  ctx.fillStyle = '#FFD700'; // Gold color
  ctx.strokeStyle = '#DAA520';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(c.x, c.y, size, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  
  // Draw a star/sparkle for effect
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.fillRect(c.x - 1, c.y - size + 2, 2, 2);
  ctx.fillRect(c.x + size - 4, c.y + size - 4, 2, 2);
  ctx.restore();
}

function drawBall(b) {
  ctx.save();
  var speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
  var glowAlpha = Math.min(0.4, 0.1 + speed*0.003);
  var trailLen = Math.min(30, 6 + speed*0.25);
  var dx = b.vx, dy = b.vy;
  var vmag = Math.sqrt(dx*dx + dy*dy) || 1;
  var tx = dx/vmag, ty = dy/vmag;

  // Trail for all particles
  ctx.strokeStyle = hexWithAlpha(b.color, glowAlpha);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(b.x, b.y);
  ctx.lineTo(b.x - tx*trailLen, b.y - ty*trailLen);
  ctx.stroke();

  if (b.isLytze && lytzeImage.complete) {
    // Draw Lytze as an image
    var size = b.radius * 2;
    ctx.drawImage(lytzeImage, b.x - b.radius, b.y - b.radius, size, size);
  } else {
    // Draw other balls or Lytze as a circle if image isn't loaded
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}




function mergeBlackHoles(i, j) {
  // ... (kept as is, updates BHs and stats.mergers)
  var BH1 = blackHoles[i];
  var BH2 = blackHoles[j];
  var totalMass = BH1.mass + BH2.mass;
  var newX = (BH1.x*BH1.mass + BH2.x*BH2.mass)/totalMass;
  var newY = (BH1.y*BH1.mass + BH2.y*BH2.mass)/totalMass;
  var newVX = (BH1.vx*BH1.mass + BH2.vx*BH2.mass)/totalMass;
  var newVY = (BH1.vy*BH1.mass + BH2.vy*BH2.mass)/totalMass;
  var newBH = new BlackHole(newX, newY, totalMass);
  newBH.vx = newVX;
  newBH.vy = newVY;
  newBH.horizon = Math.sqrt(BH1.horizon*BH1.horizon + BH2.horizon*BH2.horizon);
  newBH.energyBurst = 1.0;
  blackHoles.splice(Math.max(i,j),1);
  blackHoles.splice(Math.min(i,j),1);
  blackHoles.push(newBH);
  stats.mergers++;
}

function respawn(b) {
  var cx = canvas.width/2, cy = canvas.height/2;
  var bh = blackHoles[0] || { G: 28.0, mass: 4.5e4, softening: 120 };
  var base = Math.min(canvas.width, canvas.height) * 0.4;
  var r = randRange(base*0.55, base*0.95);
  var ang = randRange(0, Math.PI*2);
  var pos = polarToXY(cx, cy, r, ang);
  var vCirc = Math.sqrt((bh.G * bh.mass) / (r + bh.softening));
  var tx = -Math.sin(ang), ty = Math.cos(ang);
  b.x = pos.x; b.y = pos.y;
  b.vx = tx*vCirc; b.vy = ty*vCirc;
  b.life = 0;
}

function fadeTrail(alpha) {
  ctx.fillStyle = 'rgba(0,0,8,'+alpha+')';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawBlackHole(BH) {
  // ... (kept as is)
  var cx = BH.x, cy = BH.y;

  // Energy burst effect on merger
  if (BH.energyBurst > 0) {
    var burstRadius = BH.horizon * (4 + 20 * BH.energyBurst);
    var burstGrad = ctx.createRadialGradient(cx, cy, BH.horizon, cx, cy, burstRadius);
    burstGrad.addColorStop(0, 'rgba(255,255,200,'+BH.energyBurst+')');
    burstGrad.addColorStop(1, 'rgba(255,255,200,0)');
    ctx.fillStyle = burstGrad;
    ctx.beginPath();
    ctx.arc(cx, cy, burstRadius, 0, Math.PI*2);
    ctx.fill();
    BH.energyBurst *= 0.92; // fade burst
  }

  // Accretion glow
  var glow = ctx.createRadialGradient(cx, cy, BH.horizon*0.7, cx, cy, BH.horizon*4.0);
  glow.addColorStop(0, 'rgba(255,200,100,0.18)');
  glow.addColorStop(0.35, 'rgba(255,140,60,0.12)');
  glow.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(cx, cy, BH.horizon*4.0, 0, Math.PI*2);
  ctx.fill();

  // Event horizon
  var horizonGrad = ctx.createRadialGradient(cx, cy, BH.horizon*0.2, cx, cy, BH.horizon);
  horizonGrad.addColorStop(0, 'rgba(0,0,0,1)');
  horizonGrad.addColorStop(1, 'rgba(10,10,20,1)');
  ctx.fillStyle = horizonGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, BH.horizon, 0, Math.PI*2);
  ctx.fill();
}

function hexWithAlpha(hex, alpha) {
 
  var r = parseInt(hex.substring(1,3),16);
  var g = parseInt(hex.substring(3,5),16);
  var b = parseInt(hex.substring(5,7),16);
  return 'rgba('+r+','+g+','+b+','+alpha+')';
}

function drawHUD() {
  ctx.save();
  ctx.font = '14px monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
 
  
  //THE TEXT!
  var lines = [
    'LEVEL: ' + stats.level,
    'Black holes: ' + blackHoles.length,
    'Lytze size: ' + balls[PLAYER_BALL_INDEX].radius,
    'Absorbed: ' + stats.absorbed,
    'Mergers: ' + stats.mergers,
    'Lytze the Fuzbal Prototype ',
    'By viewing this prototype, you agree to our terms of service. Stenoip Company '
  ];
  var y = 24;
  for (var i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], 18, y);
    y += 18;
  }
  ctx.restore();
}

// Add new black hole on click/tap
canvas.addEventListener('click', function(e) {
  var rect = canvas.getBoundingClientRect();
  var x = e.clientX - rect.left;
  var y = e.clientY - rect.top;
  blackHoles.push(new BlackHole(x, y));
});

// Initialize and run
setupLevel(1); // Start the game at level 1
ctx.fillStyle = 'rgb(0,0,8)';
ctx.fillRect(0, 0, canvas.width, canvas.height);
requestAnimationFrame(step);
</script>
</body>
</html>
